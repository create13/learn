<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		<script>
			/*
			 * 
			 * 			var patten = /go\sogle/; // \s表示空格匹配
			var str = 'go ogle';
			alert(patten.test(str));
						var patten = /go\bogle/; // \b表示到达边界
			var str = 'google'; //false
			alert(patten.test(str));
						var patten = /google|baidu|bing/;//表示匹配或选择模式
			var str = 'this is a bing'; //true 匹配概念 不是相当 相当于包含的意思
			alert(patten.test(str));
						var patten = /google{4,8}$/; //4到8位
			var str = 'googleeee';   //true
			alert(patten.test(str));
						var patten = /(google){4,8}$/; //分组，可以堪称一个字符
			var str = 'googlegooglegooglegoogle';   //表示google4到8次   //true
			alert(patten.test(str));
						var patten = /8(.*)8/;
			var str = 'this is a 8google8';  //true
			patten.test(str) //必须要运行一下
			alert(RegExp.$1); //RegExp.$1表示获取模式中第一个分组对应的匹配字符串
						var patten = /8(.*)8/;
			var str = 'this is a 8sousou8';
			document.write(str.replace(patten,'<strong>$1<strong>'));  //加粗
						var patten = /(.*)\s(.*)/;
			var str = 'google baidu';
			alert(str.replace(patten,'$2 $1'));  //位置交换 显示的是  百度 google
						var patten = /[a-z]+/;  //贪婪 所有的字符串变成了1
			var str = 'abcdefg';
			alert(str.replace(patten,'1'));
						var patten = /[a-z]？+/;  //惰性模式
			var str = 'abcdefg';
			alert(str.replace(patten,'1')); //只有第一个字符变成1 后面没匹配
						var patten = /[a-z]？+/g;  //开启全局，并且使用惰性模式
			var str = 'abcdefg';
			alert(str.replace(patten,'1')); //每一个字母，变成了1
						var patten = /8(.*)8/; //使用了贪婪 匹配到了8google8 8google8 8google8
			var str = '8google8 8google8 8google8';
			alert(str.replace(patten,'<strong>$1<strong>'));  //google8 8google8 8google
									var patten = /8(.*?)8/; //使用了惰性，开启全局
			var str = '8google8 8google8 8google8';
			alert(str.replace(patten,'<strong>$1<strong>'));  //google google google加粗
						var patten = /8([^8]*)8/; //另一种惰性 屏蔽了8的匹配，也就是两边包含字符
			var str = '8google8 8google8 8google8';
			alert(str.replace(patten,'<strong>$1<strong>'));  
//google google google加粗
			 */

		</script>
	</body>
</html>
