<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>function</title>
		<script>
		/*
			var patten = /^[\w]+\.(zip|rar|gz)$/; //|选择符必须用分组符号包含起来
			var str = '123.rar';
			alert(patten.exec(str));		 
		
		function box(num1,num2){  //普通函数的声明方式
			return num1+num2
		}
		alert(box(1,2));
		
		var box = function(num1,num2){  //使用变量初始化函数
			return num1+num2
		}
		alert(box(1,2));
		
		var box = new Function("num1","num2","return num1+num2") //使用new运算符的构造函数来声明函数
		alert(box(1,2));
		//函数可以传递函数 下面的例子很普通，不是作为函数来传递的，而是作为函数的返回值来传递的
		function box(sum,num){
			return sum+num;
		}
		function sum(num){
			return num + 10;
		}
		
	var result = box(sum(10),10);//sum(10)这里传递的是函数的返回值，和普通的变量一样
	alert(result);
	
		// 要把函数本身作为参数传递，而不是函数的结果
		function box(sum,num){
			return sum(num);
		}
		function sum(num){
			return num + 10;
		}
		var result = box(sum,10);   //这里sum是一个函数，当作参数传递到另外一个函数里，而不是函数的返回值
		alert(result);
		//递归
		function box(num){
			if(num <= 1){
				return 1;
			}else{
				return num * box(num-1);  //4*3*2*1=24 阶乘，递归
			}
		}
		alert(box(3));
		
***		function sum(num){
			if(num <= 1){
				return 1;
			}else{
				return num * arguments.callee(num-1);  //使用arguments.callee，调用自身，实现递归 arguments.callee(num-1) 相当于 sum(num-1); 之所以用arguments.callee是因为如果外部函数名称改变 需要将内部的都逐一改变，为了方便 只需改变外部名称，内部不受影响。所以arguments.callee显得非常有作用
			}
		}
		alert(sum(4));
		
		//window是一个对象，而且是js里面最大的对象，是最外围的对象
		alert(window);  //[object Window] object类型 window是对象 类型是对象 window表示全局
		alert(this);  //[object Window] this目前表示的是window,因为在window的范围下
		alert(typeof this); //和window一模一样，所以这时的this就是window
		
		var color = "红色"; //这里color就是全局变量，而这个变量又是window的属性
		alert(window.color); //这里已经很好的说明color是window下的属性
		alert(this.color);  //同上
		
		window.color = "红色的"; //相当于var color = "红色的" 是一样的
		alert(this.color); // 类型是 [object Window]
***		var box = {
			color:"蓝色的",  //这里的color是box下的属性，也就是局部变量
			sayColor:function(){
				alert(this.color); //这里的this,我们确定代表的是box对象 类型是 [object object]
			}
		}
		box.sayColor();
		
		
***		window.color = "红色的";
		function sayColor(){
			var color ="blue";
			alert(this.color); //这个外面没有对象对其包含 因此this.color仍旧window下的是红色的   alert(this)弹出的是[object Window] 
		}
		sayColor();  //这里调用sayColor，其实范围还是在window下 
		
***		window.color = "红色的";
		function sayColor(){
			alert(this.color); // 所以这里执行的时候是动态的，第一次在window下，第二次在box下
		}
		sayColor();  //这里调用sayColor，其实范围还是在window下 
		var box = {
			color:"黄色的"
		};
		box.sayColor = sayColor; //这段代码相当于76行这段代码
		box.sayColor(); //这里执行的是box里面的this.color
		
		//属性和方法
		function box(name,age){
			return name + age;
		}
	alert(box.length);	
	
			
*****	function box(numed1,numed2){
			return numed1 + numed2;
		}
		
		function sum(num1,num2){  //apply和call可以冒充另外一个函数
			return box.apply(this,[num1,num2]); //this表示window作用域，[]表示传递的参数 如果参数传递的非常多的话，数组的长度就会非常长，这样我们可以用其他的方式，arguments
		}
		function sum2(val,res){
			return box.apply(this,arguments); //这个可以当数组传递
		}
		alert(sum2(30,10));
		
				
*****	function box(num1,num2){
				return num1 + num2;
		}
		
		function sum(num1,num2){
			return box.call(this,num1,num2); //call只是传递参数不同 其他和apply一样
		}
		alert(sum(15,15));
	
		 */


		var color = "红色";   //全局
		var box = {
			color:'蓝色的'    //局部
		}
		function sayColor(){
			alert(this.color);
		}
		sayColor();    //全局
		//用call来实现对象冒充，冒充box下，冒充window下
		sayColor.call(window);  //冒充window 红色的
		sayColor.call(this);  //this就是window
		sayColor.call(box);  //冒充box,作用域就在box对象里面，所以color就是蓝色的
		sayColor.apply(box); //蓝色
		</script>
	</head>
	<body>
	</body>
</html>
